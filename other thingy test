local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

-- Create a draggable frame
local Frame = Instance.new("Frame")
Frame.Size = UDim2.new(0.4, 0, 0.8, 0) -- Relative size (40% width, 80% height)
Frame.Position = UDim2.new(0.5, -Frame.Size.X.Offset / 2, 0.5, -Frame.Size.Y.Offset / 2) -- Centered on screen
Frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0) -- Black background for the frame
Frame.BackgroundTransparency = 0.5 -- Semi-transparent
Frame.Visible = true -- Initially visible
Frame.Parent = ScreenGui

-- Create a header for dragging
local Header = Instance.new("Frame")
Header.Size = UDim2.new(1, 0, 0.1, 0) -- Header size (full width, 10% height of the frame)
Header.Position = UDim2.new(0, 0, 0, 0) -- Positioned at the top of the frame
Header.BackgroundColor3 = Color3.fromRGB(50, 50, 50) -- Dark gray background for the header
Header.Parent = Frame

-- Create a draggable toggle button
local draggableButton = Instance.new("TextButton")
draggableButton.Size = UDim2.new(0, 50, 0, 50) -- Small square button
draggableButton.Position = UDim2.new(0.05, 0, 0.05, 0) -- Initial position on screen
draggableButton.Text = "+"
draggableButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100) -- Gray background
draggableButton.TextScaled = true
draggableButton.Parent = ScreenGui

-- Create a UIAspectRatioConstraint to maintain aspect ratio of the frame
local AspectRatio = Instance.new("UIAspectRatioConstraint")
AspectRatio.AspectRatio = 4 / 3 -- Adjust as needed
AspectRatio.Parent = Frame

-- Create and configure a UIListLayout to arrange buttons vertically
local UIListLayout = Instance.new("UIListLayout")
UIListLayout.Parent = Frame
UIListLayout.FillDirection = Enum.FillDirection.Vertical
UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
UIListLayout.VerticalAlignment = Enum.VerticalAlignment.Top
UIListLayout.Padding = UDim.new(0, 10) -- 10 pixels of padding between buttons

local buttonWidth = 0.9 -- Relative width (90% of frame width)
local buttonHeight = 0.08 -- Relative height (8% of frame height)

local function createButton(text)
    local button = Instance.new("TextButton")
    button.Size = UDim2.new(buttonWidth, 0, buttonHeight, 0)
    button.Text = text
    button.Parent = Frame
    return button
end

local TextBox = Instance.new("TextBox")
TextBox.Size = UDim2.new(0.9, 0, 0.1, 0) -- Slightly larger to fit well inside the frame
TextBox.Position = UDim2.new(0.5, -TextBox.Size.X.Offset / 2, 0.12, 0) -- Positioned below the header
TextBox.Text = "monsters name here"
TextBox.Parent = Frame

local Button1 = createButton("Equip")
local Button2 = createButton("Unequip")
local Button3 = createButton("Normal")
local ToggleButton = createButton("Enable tower duping(laggy)")
local MorphButton = createButton("Morph")
local RainbowButton = createButton("Random Rainbow Title")
local RandomTowerButton = createButton("Random Tower")

local loopEnabled = false
local isNormal = true
local rainbowLoopEnabled = false
local randomTowerLoopEnabled = false

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local EquipRemote = ReplicatedStorage:WaitForChild("Equip")
local Equip2Remote = ReplicatedStorage:WaitForChild("Equip2")
local TitleRemote = ReplicatedStorage:WaitForChild("Title")

local monsterMapping = {
    -- (Your monster mapping here)
}

local function getMonsterId(monsterName)
    return monsterMapping[monsterName] or monsterMapping[monsterName:lower()] or nil
end

local function runLoop(monsterId)
    while loopEnabled do
        local args1 = { [1] = monsterId, [2] = 1 }
        EquipRemote:FireServer(unpack(args1))
        wait(0)
        
        local args2 = { [1] = monsterId, [2] = 2 }
        EquipRemote:FireServer(unpack(args2))
        
        local args3 = { [1] = monsterId, [2] = 2 }
        EquipRemote:FireServer(unpack(args3))
        wait(0.1)
    end
end

local function fireEquipRemote(monsterId, equipType)
    if isNormal then
        EquipRemote:FireServer(monsterId, equipType)
    else
        local args = { [1] = monsterId - 1000, [2] = equipType }
        Equip2Remote:FireServer(unpack(args))
    end
end

Button1.MouseButton1Click:Connect(function()
    local monsterId = getMonsterId(TextBox.Text)
    if monsterId then
        fireEquipRemote(monsterId, 1)
    end
end)

Button2.MouseButton1Click:Connect(function()
    local monsterId = getMonsterId(TextBox.Text)
    if monsterId then
        fireEquipRemote(monsterId, 2)
    end
end)

Button3.MouseButton1Click:Connect(function()
    isNormal = not isNormal
    Button3.Text = isNormal and "Normal" or "Special"
end)

ToggleButton.MouseButton1Click:Connect(function()
    local monsterId = getMonsterId(TextBox.Text)
    if monsterId then
        loopEnabled = not loopEnabled
        ToggleButton.Text = loopEnabled and "Disable tower duping" or "Enable tower duping(laggy)"

        if loopEnabled then
            coroutine.wrap(function()
                runLoop(monsterId)
            end)()
        end
    end
end)

MorphButton.MouseButton1Click:Connect(function()
    local monsterId = getMonsterId(TextBox.Text)
    if monsterId then
        local args = { [1] = monsterId + 1000 }
        TitleRemote:FireServer(unpack(args))
    end
end)

RainbowButton.MouseButton1Click:Connect(function()
    rainbowLoopEnabled = not rainbowLoopEnabled
    RainbowButton.Text = rainbowLoopEnabled and "Stop Rainbow Title" or "Random Rainbow Title"

    if rainbowLoopEnabled then
        coroutine.wrap(function()
            while rainbowLoopEnabled do
                local args = { [1] = 19 }
                TitleRemote:FireServer(unpack(args))
                
                local args = { [1] = math.random(1001, 1052) }
                TitleRemote:FireServer(unpack(args))
                wait(0)
                
                local args = { [1] = 19 }
                TitleRemote:FireServer(unpack(args))
                
                local args = { [1] = math.random(1501, 1512) }
                TitleRemote:FireServer(unpack(args))
                wait(0)
                
                local args = { [1] = 19 }
                TitleRemote:FireServer(unpack(args))
            end
        end)()
    end
end)

RandomTowerButton.MouseButton1Click:Connect(function()
    randomTowerLoopEnabled = not randomTowerLoopEnabled
    RandomTowerButton.Text = randomTowerLoopEnabled and "Stop Random Tower" or "Random Tower"
    
    if randomTowerLoopEnabled then
        coroutine.wrap(function()
            while randomTowerLoopEnabled do
                local args = { [1] = math.random(1, 10) }
                EquipRemote:FireServer(unpack(args))
                wait(0.1)
            end
        end)()
    end
end)

-- Function to handle the draggable toggle button for showing/hiding the frame
local isVisible = false
draggableButton.MouseButton1Click:Connect(function()
    isVisible = not isVisible
    Frame.Visible = isVisible
    draggableButton.Text = isVisible and "-" or "+"
end)

-- Make the frame draggable by dragging the header
local dragToggle = nil
local dragStart = nil
local startPos = nil

local function update(input)
    local delta = input.Position - dragStart
    Frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

Header.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragToggle = true
        dragStart = input.Position
        startPos = Frame.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragToggle = false
            end
        end)
    end
end)

Header.InputChanged:Connect(function(input)
    if (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) and dragToggle then
        update(input)
    end
end)

-- Make the draggable button itself draggable
local button
